version: 2.1

orbs:
  slack: circleci/slack@4.12.5

commands:
  destroy-environment:
    description: Destroy stack resources with stack name
    parameters:
      vpcStackEName:
        type: string
        default: ""
      eksStackEName:
        type: string
        default: ""
    steps:
      - run:
          name: Destroy environment
          when: on_fail
          command: |
            #delete vpc
            vpcStackENameVar="<< parameters.vpcStackEName >>"
            if [[ "${vpcStackENameVar}" -ne ""]]
            then
               echo "delete vpc ${vpcStackENameVar}"
              #aws cloudformation delete-stack --stack-name $vpcStackENameVar
            fi
            #delete eks
            eksStackENameVar="<< parameters.eksStackEName >>"
            if [[  "${eksStackENameVar}" -ne "" ]]
            then
               echo "delete eks ${eksStackENameVar}" 
               #aws cloudformation delete-stack --stack-name $eksStackENameVar
            fi

  command-install-kubectl:
    description: command-install-kubectl
    steps:
      - run:
          name: install dependencies
          command: |
            curl -LO https://dl.k8s.io/release/`curl -LS https://dl.k8s.io/release/stable.txt`/bin/linux/amd64/kubectl
            chmod +x ./kubectl
            mv ./kubectl /usr/local/bin/kubectl
            aws eks update-kubeconfig --name eksCluster
            # kubectl version --client

  start-rolling-deployment:
    description: start-rolling-deployment
    parameters:
      manifestsName:
        type: string
        default: ""
      deploymentName:
        type: string
        default: ""
      tag:
        type: string
        default: ""
    steps:
      - run:
          name: deploy container
          command: |
            deployment_name="<< parameters.deploymentName >>"
            manifest_name="<< parameters.manifestsName >>"
            tag="<< parameters.tag >>"
            

            # Check if the deployment exists
            deployment_output=$(kubectl get deployments -o json)

            
            sed 's/#IMAGE_DOCKER_TAG/${tag}/g' "${manifest_name}"
            cat $manifest_name

            if echo "$deployment_output" | grep -q "$deployment_name"; then
              echo "Update image ${deployment_name} : ${tag}"
              kubectl apply -f "${manifest_name}" --record
            else
              echo "Init deploy for the first time of the deployment"
              kubectl apply -f "${manifest_name}" --record
            fi

jobs:
  build-frontend:
    docker:
      - image: circleci/node:13.8.0
    steps:
      - checkout
      - restore_cache:
          keys: [frontend-build]
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Get backend url
          command: |
            export BACKEND_IP=$(</tmp/workspace/backendDns.txt)
            export API_URL="http://${BACKEND_IP}:3030"
            echo "API_URL = ${API_URL}"
            echo API_URL="http://${BACKEND_IP}:3030" >> frontend/.env
            echo NODE_ENV="production" >> frontend/.env
            echo | cat frontend/.env
      - run:
          name: Build front-end
          command: |
            cd frontend
            npm install
            npm run build
            tar -czvf artifact-front.tar.gz dist
            # no error if existing, make a directory
            mkdir -p /tmp/workspace
            mv dist /tmp/workspace/artifact-front.tar.gz
      - persist_to_workspace:
          root: /tmp/workspace
          paths:
            - artifact-front.tar.gz
      - save_cache:
          paths: [frontend/node_modules]
          key: frontend-build

  build-backend:
    docker:
      - image: circleci/node:13.8.0
    steps:
      - checkout
      - restore_cache:
          keys: [backend-build]
      - run:
          name: Back-end build
          command: |
            cd backend
            touch .env
            echo NODE_ENV=production >> .env
            echo TYPEORM_HOST=$TYPEORM_HOST >> .env
            echo TYPEORM_CONNECTION=$TYPEORM_CONNECTION >> .env
            echo TYPEORM_DATABASE=$TYPEORM_DATABASE >> .env
            echo TYPEORM_ENTITIES=$TYPEORM_ENTITIES >> .env
            echo TYPEORM_MIGRATIONS=$TYPEORM_MIGRATIONS >> .env
            echo TYPEORM_MIGRATIONS_DIR=$TYPEORM_MIGRATIONS_DIR >> .env
            echo TYPEORM_PASSWORD=$TYPEORM_PASSWORD >> .env
            echo TYPEORM_PORT=$TYPEORM_PORT >> .env
            echo TYPEORM_USERNAME=$TYPEORM_USERNAME >> .env
            npm install
            npm run build
            cd ..
            tar -C backend -czvf artifact.tar.gz .
            # no error if existing, make a directory
            mkdir -p /tmp/workspace
            mv artifact.tar.gz /tmp/workspace/artifact.tar.gz
      - persist_to_workspace:
          root: /tmp/workspace
          paths:
            - "artifact.tar.gz"
      - save_cache:
          paths: [backend/node_modules]
          key: backend-build

  build-frontend-docker:
    docker:
      - image: docker:17.05.0-ce-git
    steps:
      - checkout
      - setup_remote_docker
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Install dependencies
          command: |
            apk add --no-cache \
              py-pip=9.0.0-r1
            pip install \
              docker-compose==1.12.0 \
              awscli==1.11.76
            docker --version
      - run:
          name: build frontend docker image
          command: |
            mv /tmp/workspace/artifact-front.tar.gz dist
            docker build --file=front.Dockerfile  -t uda-web-frontend .
            docker images
            # Create dockerpath
            dockerpath="nyubblue/uda-web-frontend"

            # Authenticate & tag
            echo "Docker ID and Image: $dockerpath"
            docker tag uda-web-frontend "${dockerpath}:${FRONT_NEW_VERSION_TAG}"
            docker login -u="nyubblue" -p="${DOCKER_PASSWORD}"
            # Push image to a docker repository
            docker push "${dockerpath}:${FRONT_NEW_VERSION_TAG}"

  build-backend-docker:
    docker:
      - image: docker:17.05.0-ce-git
    steps:
      - checkout
      - setup_remote_docker
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Install dependencies
          command: |
            apk add --no-cache \
              py-pip=9.0.0-r1
            pip install \
              docker-compose==1.12.0 \
              awscli==1.11.76
            docker --version
      - run:
          name: build backend docker image
          command: |
            mv /tmp/workspace/artifact.tar.gz .
            docker build --file=back.Dockerfile  -t uda-web-backend .
            docker images
            # Create dockerpath
            dockerpath="nyubblue/uda-web-backend"

            # Authenticate & tag
            echo "Docker ID and Image: $dockerpath"
            docker tag uda-web-backend "${dockerpath}:${BACK_NEW_VERSION_TAG}"
            docker login -u="nyubblue" -p="${DOCKER_PASSWORD}"
            # Push image to a docker repository
            docker push "${dockerpath}:${BACK_NEW_VERSION_TAG}"

  build-infrastructure:
    docker:
      - image: amazon/aws-cli
    environment:
      TERM: ansi
    steps:
      - checkout
      - run:
          name: deploy vpc
          no_output_timeout: 10m
          command: |
            cd .circleci/infrastructure
            if aws cloudformation describe-stacks --stack-name "$VPC_STACKNAME" >/dev/null 2>/dev/null;
            then
              chmod +x update.sh
              ./update.sh $VPC_STACKNAME vpc.yml params.json

            else
              chmod +x create.sh
              ./create.sh $VPC_STACKNAME vpc.yml params.json
            fi

      - run:
          name: deploy eks
          no_output_timeout: 30m
          command: |
            cd .circleci/infrastructure
            if aws cloudformation describe-stacks --stack-name "$EKS_STACKNAME" >/dev/null 2>/dev/null;
            then
              chmod +x update.sh
              ./update.sh $EKS_STACKNAME eks.yml params.json
            else
              chmod +x create.sh
              ./create.sh $EKS_STACKNAME eks.yml params.json
            fi
      - destroy-environment:
          vpcStackEName: "$VPC_STACKNAME"
          eksStackEName: "$EKS_STACKNAME"

  rolling-deploy-backend:
    docker:
      - image: amazon/aws-cli
    environment:
      TERM: ansi
    steps:
      - checkout
      - command-install-kubectl
      - start-rolling-deployment:
            manifestsName: "deployment_back.yml"
            deploymentName: "backend"
            tag: "${BACK_NEW_VERSION_TAG}"

  rolling-deploy-frontend:
    docker:
      - image: amazon/aws-cli
    environment:
      TERM: ansi
    steps:
      - checkout
      - command-install-kubectl
      - start-rolling-deployment:
            manifestsName: "deployment_front.yml"
            deploymentName: "frontend"
            tag: "${FRONT_NEW_VERSION_TAG}"

  get-backend-backend-dns:
    docker:
      - image: amazon/aws-cli
    environment:
      TERM: ansi
    steps:
      - checkout
      - command-install-kubectl
      - run:
          name: get dns of backend api
          command: |
            external_ip=$(kubectl get service/frontend-service --output=jsonpath='{.status.loadBalancer.ingress[0].hostname}')
            echo "API DNS : ${external_ip}"
            mkdir -p /tmp/workspace
            echo "${external_ip}" > /tmp/workspace/backendDns.txt
      - run: yum -y install tar gzip  
      - persist_to_workspace:
          root: /tmp/workspace
          paths:
            - backendDns.txt
workflows:
  default:
    jobs:
      - build-infrastructure
      - build-backend
      - build-backend-docker:
          requires: [build-backend]
      - rolling-deploy-backend:
          requires: [build-backend-docker]
      - get-backend-backend-dns:
          requires: [rolling-deploy-backend]
      - build-frontend:
          requires: [get-backend-backend-dns]
      - build-frontend-docker:
          requires: [build-frontend]

      #- rolling-deployment:
      #        requires: [build-infrastructure]