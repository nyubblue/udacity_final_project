version: 2.1

orbs:
  slack: circleci/slack@4.12.5

commands:
  destroy-environment:
    description: Destroy stack resources with stack name
    parameters:
      vpcStackEName:
        type: string
        default: ""
      eksStackEName:
        type: string
        default: ""
    steps:
      - run:
          name: Destroy environment
          when: on_fail
          command: |
            #delete vpc
            vpcStackENameVar="<< parameters.vpcStackEName >>"
            if [[ "${vpcStackENameVar}" -ne ""]]
            then
               echo "delete vpc ${vpcStackENameVar}"
              #aws cloudformation delete-stack --stack-name $vpcStackENameVar
            fi
            #delete eks
            eksStackENameVar="<< parameters.eksStackEName >>"
            if [[  "${eksStackENameVar}" -ne "" ]]
            then
               echo "delete eks ${eksStackENameVar}" 
               #aws cloudformation delete-stack --stack-name $eksStackENameVar
            fi
            

jobs:
  build-frontend:
    docker:
      - image: circleci/node:13.8.0
    steps:
      - checkout
      - restore_cache:
          keys: [frontend-build]
      - run:
          name: Get backend url
          command: |
            export BACKEND_IP="backend-service"
            export API_URL="http://${BACKEND_IP}:3030"
            echo "API_URL = ${API_URL}"
            echo API_URL="http://${BACKEND_IP}:3030" >> frontend/.env
            echo NODE_ENV="production" >> frontend/.env
            echo | cat frontend/.env
      - run:
          name: Build front-end
          command: |
            cd frontend
            npm install
            npm run build
            tar -czvf artifact-front.tar.gz dist
            # no error if existing, make a directory
            mkdir -p /tmp/workspace
            mv dist /tmp/workspace/artifact-front.tar.gz
      - persist_to_workspace:
          root: /tmp/workspace
          paths:
            - artifact-front.tar.gz
      - save_cache:
          paths: [frontend/node_modules]
          key: frontend-build

  build-backend:
    docker:
      - image: circleci/node:13.8.0
    steps:
      - checkout
      - restore_cache:
          keys: [backend-build]
      - run:
          name: Back-end build
          command: |
            cd backend
            touch .env
            echo NODE_ENV=production >> .env
            echo TYPEORM_HOST=$TYPEORM_HOST >> .env
            echo TYPEORM_CONNECTION=$TYPEORM_CONNECTION >> .env
            echo TYPEORM_DATABASE=$TYPEORM_DATABASE >> .env
            echo TYPEORM_ENTITIES=$TYPEORM_ENTITIES >> .env
            echo TYPEORM_MIGRATIONS=$TYPEORM_MIGRATIONS >> .env
            echo TYPEORM_MIGRATIONS_DIR=$TYPEORM_MIGRATIONS_DIR >> .env
            echo TYPEORM_PASSWORD=$TYPEORM_PASSWORD >> .env
            echo TYPEORM_PORT=$TYPEORM_PORT >> .env
            echo TYPEORM_USERNAME=$TYPEORM_USERNAME >> .env
            npm install
            npm run build
            cd ..
            tar -C backend -czvf artifact.tar.gz .
            # no error if existing, make a directory
            mkdir -p /tmp/workspace
            mv artifact.tar.gz /tmp/workspace/artifact.tar.gz
      - persist_to_workspace:
          root: /tmp/workspace
          paths:
            - "artifact.tar.gz"
      - save_cache:
          paths: [backend/node_modules]
          key: backend-build

  build-frontend-docker:
    docker:
      - image: docker:17.05.0-ce-git
    steps:
      - checkout
      - setup_remote_docker
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Install dependencies
          command: |
            apk add --no-cache \
              py-pip=9.0.0-r1
            pip install \
              docker-compose==1.12.0 \
              awscli==1.11.76
            docker --version
      - run:
          name: build frontend docker image
          command: |
            mv /tmp/workspace/artifact-front.tar.gz dist
            docker build --file=front.Dockerfile  -t uda-web-frontend .
            docker images
            # Create dockerpath
            dockerpath="nyubblue/uda-web-frontend"

            # Authenticate & tag
            echo "Docker ID and Image: $dockerpath"
            docker tag uda-web-frontend "${dockerpath}:${FRONT_NEW_VERSION_TAG}"
            docker login -u="nyubblue" -p="${DOCKER_PASSWORD}"
            # Push image to a docker repository
            docker push "${dockerpath}:${FRONT_NEW_VERSION_TAG}"

  build-backend-docker:
    docker:
      - image: docker:17.05.0-ce-git
    steps:
      - checkout
      - setup_remote_docker
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Install dependencies
          command: |
            apk add --no-cache \
              py-pip=9.0.0-r1
            pip install \
              docker-compose==1.12.0 \
              awscli==1.11.76
            docker --version
      - run:
          name: build backend docker image
          command: |
            mv /tmp/workspace/artifact.tar.gz /artifact.tar.gz
            docker build --file=back.Dockerfile  -t uda-web-backend .
            docker images
            # Create dockerpath
            dockerpath="nyubblue/uda-web-backend"

            # Authenticate & tag
            echo "Docker ID and Image: $dockerpath"
            docker tag uda-web-frontend "${dockerpath}:${BACK_NEW_VERSION_TAG}"
            docker login -u="nyubblue" -p="${DOCKER_PASSWORD}"
            # Push image to a docker repository
            docker push "${dockerpath}:${BACK_NEW_VERSION_TAG}"

  build-infrastructure:
    docker:
      - image: amazon/aws-cli
    environment:
      TERM: ansi
    steps:
      - checkout
      - run:
          name: deploy vpc
          no_output_timeout: 10m
          command: |
            cd .circleci/infrastructure
            if aws cloudformation describe-stacks --stack-name "$VPC_STACKNAME" >/dev/null 2>/dev/null;
            then
              chmod +x update.sh
              ./update.sh $VPC_STACKNAME vpc.yml params.json

            else
              chmod +x create.sh
              ./create.sh $VPC_STACKNAME vpc.yml params.json
            fi

      - run:
          name: deploy eks
          no_output_timeout: 30m
          command: |
            cd .circleci/infrastructure
            if aws cloudformation describe-stacks --stack-name "$EKS_STACKNAME" >/dev/null 2>/dev/null;
            then
              chmod +x update.sh
              ./update.sh $EKS_STACKNAME eks.yml params.json
            else
              chmod +x create.sh
              ./create.sh $EKS_STACKNAME eks.yml params.json
            fi
      - destroy-environment:
          vpcStackEName: "$VPC_STACKNAME"
          eksStackEName: "$EKS_STACKNAME"

  rolling-deployment:
    docker:
      - image: amazon/aws-cli
    environment:
      TERM: ansi
    steps:
      - checkout
      - run:
          name: install dependencies
          command: |
            curl -LO https://dl.k8s.io/release/`curl -LS https://dl.k8s.io/release/stable.txt`/bin/linux/amd64/kubectl
            chmod +x ./kubectl
            mv ./kubectl /usr/local/bin/kubectl
            aws eks update-kubeconfig --name eksCluster
            kubectl version --client
      - run:
          name: deploy container
          command: |
            deployment_back="back-end"
            deployment_front="front-end"

            # Check if the deployment exists
            deployment_output=$(kubectl get deployments -o json)

            if [[ echo "$deployment_output" | grep -q "$deployment_back" ]] && [[ echo "$deployment_output" | grep -q "$deployment_front" ]] ; then
              kubectl apply -f deployment-front.yml
              kubectl apply -f deployment-back.yml
            else
              echo "Init deploy for the first time of the deployment"
              kubectl apply -f deployment-front.yml
              kubectl apply -f deployment-back.yml
              exit 0
            fi

workflows:
  default:
    jobs:
      - build-frontend
      - build-backend
      - build-infrastructure:
          requires: [build-frontend, build-backend]
      - build-frontend-docker:
          requires: [build-frontend]
      - build-backend-docker:
          requires: [build-backend]
      #- rolling-deployment:
      #        requires: [build-infrastructure]