version: 2.1
commands:
  destroy-environment:
    description: Destroy stack resources with stack name
    parameters:
      vpcStackEName:
        type: string
        default: ""
      eksStackEName:
        type: string
        default: ""
    steps:
      - run:
          name: Destroy environment
          when: on_fail
          command: |
            #delete vpc
            vpcStackENameVar="<< parameters.vpcStackEName >>"
            if [[ "${vpcStackENameVar}" -ne ""]]
            then
               echo "delete vpc ${vpcStackENameVar}"
              #aws cloudformation delete-stack --stack-name $vpcStackENameVar
            fi
            #delete eks
            eksStackENameVar="<< parameters.eksStackEName >>"
            if [[  "${eksStackENameVar}" -ne "" ]]
            then
               echo "delete eks ${eksStackENameVar}" 
               #aws cloudformation delete-stack --stack-name $eksStackENameVar
            fi

  command-install-kubectl:
    description: command-install-kubectl
    steps:
      - run:
          name: install dependencies
          command: |
            curl -LO https://dl.k8s.io/release/`curl -LS https://dl.k8s.io/release/stable.txt`/bin/linux/amd64/kubectl
            chmod +x ./kubectl
            mv ./kubectl /usr/local/bin/kubectl
            aws eks update-kubeconfig --name eksCluster
            # kubectl version --client

  start-rolling-deployment:
    description: start-rolling-deployment
    parameters:
      manifestsName:
        type: string
        default: ""
      deploymentName:
        type: string
        default: ""
      tag:
        type: string
        default: ""
    steps:
      - run:
          name: deploy container
          command: |
            deployment_name="<< parameters.deploymentName >>"
            manifest_name="<< parameters.manifestsName >>"
            tag="<< parameters.tag >>"
            

            # Check if the deployment exists
            deployment_output=$(kubectl get deployments -o json)

            
            sed -i "s/#IMAGE_DOCKER_TAG/${tag}/g" "${manifest_name}"
            cat $manifest_name

            if echo "$deployment_output" | grep -q "$deployment_name"; then
              echo "Update image ${deployment_name} : ${tag}"
              kubectl apply -f "${manifest_name}" --record
            else
              echo "Init deploy for the first time of the deployment"
              kubectl apply -f "${manifest_name}" --record
            fi

            # rollback when deploy failed
            if ! kubectl rollout status deployment "${deployment_name}"; then
              exit 1
            fi

  rollback-version:
    description: rollback deployment version for any fails of new docker
    steps:
      - run:
          name: listening for failed events
          when: on_fail
          command: |
            kubectl rollout history deploy frontend
            kubectl rollout undo deployments/frontend
            kubectl rollout status
            kubectl get deployments

jobs:
  build-frontend:
    docker:
      - image: circleci/node:13.8.0
    steps:
      - checkout
      - restore_cache:
          keys: [frontend-build]
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Get backend url
          command: |
            export BACKEND_IP={BACKEND_DNS}
            export API_URL="http://${BACKEND_IP}:3030"
            echo "API_URL = ${API_URL}"
            echo API_URL="http://${BACKEND_IP}:3030" >> frontend/.env
            echo NODE_ENV="production" >> frontend/.env
            echo | cat frontend/.env
      - run:
          name: Build front-end
          command: |
            cd frontend
            npm install
            npm run build
            tar -czvf artifact-front.tar.gz dist
            # no error if existing, make a directory
            mkdir -p /tmp/workspace
            mv dist /tmp/workspace/artifact-front.tar.gz
      - persist_to_workspace:
          root: /tmp/workspace
          paths:
            - artifact-front.tar.gz
      - save_cache:
          paths: [frontend/node_modules]
          key: frontend-build

  lint-frontend:
    docker:
      - image: circleci/node:13.8.0
    steps:
      - checkout
      - restore_cache:
          keys: [frontend-build]
      - run:
          name: linting
          command: |
            cd frontend
            npm install
            npm install eslint --save-dev
            npm run lint

  test-frontend:
    docker:
      - image: circleci/node:13.8.0
    steps:
      - checkout
      - restore_cache:
          keys: [frontend-build]
      - run:
          name: Front-end test
          command: |
            cd frontend
            npm install
            npm run test

  build-frontend-docker:
    docker:
      - image: docker:17.05.0-ce-git
    steps:
      - checkout
      - setup_remote_docker
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Install dependencies
          command: |
            apk add --no-cache \
              py-pip=9.0.0-r1
            pip install \
              docker-compose==1.12.0 \
              awscli==1.11.76
            docker --version
      - run:
          name: build frontend docker image
          command: |
            mv /tmp/workspace/artifact-front.tar.gz dist
            docker build --file=front.Dockerfile  -t uda-web-frontend .
            docker images
            # Create dockerpath
            dockerpath="nyubblue/uda-web-frontend"

            # Authenticate & tag
            echo "Docker ID and Image: $dockerpath"
            docker tag uda-web-frontend "${dockerpath}:${FRONT_NEW_VERSION_TAG}"
            docker login -u="nyubblue" -p="${DOCKER_PASSWORD}"
            # Push image to a docker repository
            docker push "${dockerpath}:${FRONT_NEW_VERSION_TAG}"

  build-infrastructure:
    docker:
      - image: amazon/aws-cli
    environment:
      TERM: ansi
    steps:
      - checkout
      - run:
          name: deploy vpc
          no_output_timeout: 10m
          command: |
            cd .circleci/infrastructure
            if aws cloudformation describe-stacks --stack-name "$VPC_STACKNAME" >/dev/null 2>/dev/null;
            then
              chmod +x update.sh
              ./update.sh $VPC_STACKNAME vpc.yml params.json

            else
              chmod +x create.sh
              ./create.sh $VPC_STACKNAME vpc.yml params.json
            fi

      - run:
          name: deploy eks
          no_output_timeout: 30m
          command: |
            cd .circleci/infrastructure
            if aws cloudformation describe-stacks --stack-name "$EKS_STACKNAME" >/dev/null 2>/dev/null;
            then
              chmod +x update.sh
              ./update.sh $EKS_STACKNAME eks.yml params.json
            else
              chmod +x create.sh
              ./create.sh $EKS_STACKNAME eks.yml params.json
            fi
      - destroy-environment:
          vpcStackEName: "$VPC_STACKNAME"
          eksStackEName: "$EKS_STACKNAME"

  rolling-deploy-frontend:
    docker:
      - image: amazon/aws-cli
    environment:
      TERM: ansi
    steps:
      - checkout
      - command-install-kubectl
      - start-rolling-deployment:
            manifestsName: "deployment_front.yml"
            deploymentName: "frontend"
            tag: "${FRONT_NEW_VERSION_TAG}"
      - rollback-version

  get-frontend-dns:
    docker:
      - image: amazon/aws-cli
    environment:
      TERM: ansi
    steps:
      - checkout
      - command-install-kubectl
      - run:
          name: get dns of frontend
          command: |
            external_ip=$(kubectl get service/frontend-service --output=jsonpath='{.status.loadBalancer.ingress[0].hostname}')
            echo "FRONT DNS : ${external_ip}"
            mkdir -p /tmp/workspace
            echo "${external_ip}" > /tmp/workspace/frontendDns.txt
      - run: yum -y install tar gzip  
      - persist_to_workspace:
          root: /tmp/workspace
          paths:
            - frontendDns.txt

  smoke-test:
    docker:
      - image: amazon/aws-cli
    environment:
      TERM: ansi
    steps:
      - checkout
      - command-install-kubectl
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Frontend smoke test.
          command: |
            FRONT_DNS=$(</tmp/workspace/backendDns.txt)
            URL="http://${FRONT_DNS}/#/employees"
            echo ${URL}
            if curl -s ${URL} | grep "Welcome";
            then
              exit 0
            else
              exit 1
            fi
      - rollback-version

workflows:
  default:
    jobs:
      - build-infrastructure
      - build-frontend
      - lint-frontend
      - test-frontend:
          requires: [build-frontend, lint-frontend, build-infrastructure]
      - build-frontend-docker:
          requires: [test-frontend]
      - rolling-deploy-frontend:
          requires: [build-frontend-docker]
      - get-frontend-dns:
          requires: [rolling-deploy-frontend]
      - smoke-test:
          requires: [get-frontend-dns]